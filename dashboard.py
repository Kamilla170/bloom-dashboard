import asyncio
import asyncpg
import os
from datetime import datetime, timedelta
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.staticfiles import StaticFiles
import logging
from pathlib import Path

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Bloom AI Dashboard")

# Database URL –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
def get_database_url():
    """–ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π DATABASE_URL"""
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ü—Ä–æ–±—É–µ–º —Å–æ–±—Ä–∞—Ç—å –∏–∑ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö (–Ω–∞–¥—ë–∂–Ω–µ–µ –¥–ª—è Railway)
    pg_host = os.getenv("PGHOST")
    pg_port = os.getenv("PGPORT")
    pg_user = os.getenv("PGUSER")
    pg_password = os.getenv("PGPASSWORD")
    pg_database = os.getenv("PGDATABASE")
    
    if pg_host and pg_password:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã
        pg_port = pg_port or "5432"
        pg_user = pg_user or "postgres"
        pg_database = pg_database or "railway"
        
        database_url = f"postgresql://{pg_user}:{pg_password}@{pg_host}:{pg_port}/{pg_database}"
        logger.info("‚úÖ DATABASE_URL —Å–æ–±—Ä–∞–Ω –∏–∑ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö")
        logger.info(f"üîó –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: postgresql://{pg_user}:***@{pg_host}:{pg_port}/{pg_database}")
        return database_url
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ü—Ä–æ–±—É–µ–º DATABASE_PRIVATE_URL
    private_url = os.getenv("DATABASE_PRIVATE_URL")
    if private_url:
        logger.info("‚úÖ –ò—Å–ø–æ–ª—å–∑—É—é DATABASE_PRIVATE_URL")
        return private_url
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 3: –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ —Å DATABASE_URL
    public_url = os.getenv("DATABASE_URL")
    if public_url:
        logger.info("‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É—é DATABASE_URL (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º)")
        logger.info(f"üîç –ü–µ—Ä–≤—ã–µ 50 —Å–∏–º–≤–æ–ª–æ–≤: {public_url[:50]}...")
        return public_url
    
    logger.error("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω—ã –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î")
    logger.error("üí° –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ: PGHOST, PGPORT, PGUSER, PGPASSWORD, PGDATABASE")
    return None

DATABASE_URL = get_database_url()

# Database pool
db_pool = None

async def init_db():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π"""
    global db_pool
    
    if not DATABASE_URL:
        logger.error("‚ùå DATABASE_URL –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
        return False
    
    try:
        logger.info(f"üîå –ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ –ë–î...")
        db_pool = await asyncpg.create_pool(
            DATABASE_URL,
            min_size=1,
            max_size=3,
            timeout=30
        )
        logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
        return True
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
        logger.error(f"üí° –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ: DATABASE_URL, DATABASE_PRIVATE_URL –∏–ª–∏ PGHOST, PGPASSWORD")
        return False

@app.on_event("startup")
async def startup():
    """–ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ –¥–∞—à–±–æ—Ä–¥–∞...")
    success = await init_db()
    if success:
        logger.info("‚úÖ –î–∞—à–±–æ—Ä–¥ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")
    else:
        logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –ë–î")

@app.on_event("shutdown")
async def shutdown():
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    global db_pool
    if db_pool:
        await db_pool.close()
        logger.info("‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î –∑–∞–∫—Ä—ã—Ç–æ")

@app.get("/", response_class=HTMLResponse)
async def root():
    """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞"""
    # –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–∫—É—â–µ–≥–æ —Ñ–∞–π–ª–∞
    current_dir = Path(__file__).parent
    html_path = current_dir / "static" / "index.html"
    
    if html_path.exists():
        return FileResponse(html_path)
    else:
        logger.error(f"‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {html_path}")
        return HTMLResponse("<h1>Dashboard</h1><p>Error: index.html not found</p>")

@app.get("/api/stats/today")
async def get_today_stats():
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è"""
    if not db_pool:
        raise HTTPException(status_code=500, detail="Database not connected")
    
    try:
        async with db_pool.acquire() as conn:
            today = datetime.now().date()
            
            # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            total_users = await conn.fetchval("SELECT COUNT(*) FROM users")
            
            # –ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è
            new_users_today = await conn.fetchval("""
                SELECT COUNT(*) FROM users 
                WHERE created_at::date = $1
            """, today)
            
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª–∏–ª–∏ —Å–µ–≥–æ–¥–Ω—è
            watered_today = await conn.fetchval("""
                SELECT COUNT(DISTINCT plant_id) FROM care_history 
                WHERE action_type = 'watered' 
                AND action_date::date = $1
            """, today)
            
            # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª–∏–ª–∏
            users_watered_today = await conn.fetchval("""
                SELECT COUNT(DISTINCT p.user_id) 
                FROM care_history ch
                JOIN plants p ON ch.plant_id = p.id
                WHERE ch.action_type = 'watered' 
                AND ch.action_date::date = $1
            """, today)
            
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–±–∞–≤–∏–ª–∏ —Ä–∞—Å—Ç–µ–Ω–∏–µ —Å–µ–≥–æ–¥–Ω—è
            added_plants_today = await conn.fetchval("""
                SELECT COUNT(DISTINCT user_id) FROM plants 
                WHERE saved_date::date = $1
            """, today)
            
            # –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å–µ–≥–æ–¥–Ω—è (last_activity)
            active_today = await conn.fetchval("""
                SELECT COUNT(*) FROM users 
                WHERE last_activity IS NOT NULL 
                AND last_activity::date = $1
            """, today)
            
            # –ù–µ–∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å–µ–≥–æ–¥–Ω—è
            inactive_today = total_users - active_today if active_today else total_users
            
            # –ü—Ä–æ—Ü–µ–Ω—Ç—ã
            watered_percent = round((users_watered_today / total_users * 100), 1) if total_users > 0 else 0
            added_plants_percent = round((added_plants_today / total_users * 100), 1) if total_users > 0 else 0
            active_percent = round((active_today / total_users * 100), 1) if total_users > 0 else 0
            inactive_percent = round((inactive_today / total_users * 100), 1) if total_users > 0 else 0
            
            return {
                "date": today.isoformat(),
                "total_users": total_users,
                "new_users": new_users_today,
                "watered": {
                    "count": users_watered_today,
                    "percent": watered_percent
                },
                "added_plants": {
                    "count": added_plants_today,
                    "percent": added_plants_percent
                },
                "active": {
                    "count": active_today,
                    "percent": active_percent
                },
                "inactive": {
                    "count": inactive_today,
                    "percent": inactive_percent
                }
            }
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/stats/yesterday")
async def get_yesterday_stats():
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –≤—á–µ—Ä–∞"""
    if not db_pool:
        raise HTTPException(status_code=500, detail="Database not connected")
    
    try:
        async with db_pool.acquire() as conn:
            yesterday = (datetime.now() - timedelta(days=1)).date()
            
            # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–∞ –≤—á–µ—Ä–∞
            total_users = await conn.fetchval("""
                SELECT COUNT(*) FROM users 
                WHERE created_at::date <= $1
            """, yesterday)
            
            # –ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤—á–µ—Ä–∞
            new_users = await conn.fetchval("""
                SELECT COUNT(*) FROM users 
                WHERE created_at::date = $1
            """, yesterday)
            
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª–∏–ª–∏ –≤—á–µ—Ä–∞
            watered = await conn.fetchval("""
                SELECT COUNT(DISTINCT p.user_id) 
                FROM care_history ch
                JOIN plants p ON ch.plant_id = p.id
                WHERE ch.action_type = 'watered' 
                AND ch.action_date::date = $1
            """, yesterday)
            
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–±–∞–≤–∏–ª–∏ —Ä–∞—Å—Ç–µ–Ω–∏–µ –≤—á–µ—Ä–∞
            added_plants = await conn.fetchval("""
                SELECT COUNT(DISTINCT user_id) FROM plants 
                WHERE saved_date::date = $1
            """, yesterday)
            
            # –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤—á–µ—Ä–∞
            active = await conn.fetchval("""
                SELECT COUNT(*) FROM users 
                WHERE last_activity IS NOT NULL
                AND last_activity::date = $1
            """, yesterday)
            
            inactive = total_users - active if active else total_users
            
            # –ü—Ä–æ—Ü–µ–Ω—Ç—ã
            watered_percent = round((watered / total_users * 100), 1) if total_users > 0 else 0
            added_plants_percent = round((added_plants / total_users * 100), 1) if total_users > 0 else 0
            active_percent = round((active / total_users * 100), 1) if total_users > 0 else 0
            inactive_percent = round((inactive / total_users * 100), 1) if total_users > 0 else 0
            
            return {
                "date": yesterday.isoformat(),
                "total_users": total_users,
                "new_users": new_users,
                "watered": {
                    "count": watered,
                    "percent": watered_percent
                },
                "added_plants": {
                    "count": added_plants,
                    "percent": added_plants_percent
                },
                "active": {
                    "count": active,
                    "percent": active_percent
                },
                "inactive": {
                    "count": inactive,
                    "percent": inactive_percent
                }
            }
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/stats/week")
async def get_week_stats():
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π"""
    if not db_pool:
        raise HTTPException(status_code=500, detail="Database not connected")
    
    try:
        async with db_pool.acquire() as conn:
            days = []
            
            for i in range(7):
                day = (datetime.now() - timedelta(days=i)).date()
                
                # –ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
                new_users = await conn.fetchval("""
                    SELECT COUNT(*) FROM users WHERE created_at::date = $1
                """, day)
                
                # –ü–æ–ª–∏–≤—ã
                watered = await conn.fetchval("""
                    SELECT COUNT(DISTINCT p.user_id) 
                    FROM care_history ch
                    JOIN plants p ON ch.plant_id = p.id
                    WHERE ch.action_type = 'watered' 
                    AND ch.action_date::date = $1
                """, day)
                
                # –î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ç–µ–Ω–∏—è
                added_plants = await conn.fetchval("""
                    SELECT COUNT(DISTINCT user_id) FROM plants WHERE saved_date::date = $1
                """, day)
                
                # –ê–∫—Ç–∏–≤–Ω—ã–µ
                active = await conn.fetchval("""
                    SELECT COUNT(*) FROM users 
                    WHERE last_activity IS NOT NULL 
                    AND last_activity::date = $1
                """, day)
                
                days.append({
                    "date": day.isoformat(),
                    "new_users": new_users,
                    "watered": watered,
                    "added_plants": added_plants,
                    "active": active
                })
            
            return {"days": list(reversed(days))}
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–µ–¥–µ–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/stats/month")
async def get_month_stats():
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π"""
    if not db_pool:
        raise HTTPException(status_code=500, detail="Database not connected")
    
    try:
        async with db_pool.acquire() as conn:
            days = []
            
            for i in range(30):
                day = (datetime.now() - timedelta(days=i)).date()
                
                # –ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
                new_users = await conn.fetchval("""
                    SELECT COUNT(*) FROM users WHERE created_at::date = $1
                """, day)
                
                # –ü–æ–ª–∏–≤—ã
                watered = await conn.fetchval("""
                    SELECT COUNT(DISTINCT p.user_id) 
                    FROM care_history ch
                    JOIN plants p ON ch.plant_id = p.id
                    WHERE ch.action_type = 'watered' 
                    AND ch.action_date::date = $1
                """, day)
                
                # –î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ç–µ–Ω–∏—è
                added_plants = await conn.fetchval("""
                    SELECT COUNT(DISTINCT user_id) FROM plants WHERE saved_date::date = $1
                """, day)
                
                # –ê–∫—Ç–∏–≤–Ω—ã–µ
                active = await conn.fetchval("""
                    SELECT COUNT(*) FROM users 
                    WHERE last_activity IS NOT NULL 
                    AND last_activity::date = $1
                """, day)
                
                days.append({
                    "date": day.isoformat(),
                    "new_users": new_users,
                    "watered": watered,
                    "added_plants": added_plants,
                    "active": active
                })
            
            return {"days": list(reversed(days))}
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Å—è—á–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/health")
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è"""
    db_status = "connected" if db_pool else "disconnected"
    return {
        "status": "healthy",
        "database": db_status,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/stats/additional")
async def get_additional_stats():
    """–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏"""
    if not db_pool:
        raise HTTPException(status_code=500, detail="Database not connected")
    
    try:
        async with db_pool.acquire() as conn:
            today = datetime.now().date()
            week_ago = today - timedelta(days=7)
            
            # –í–æ–ø—Ä–æ—Å—ã
            questions_today = await conn.fetchval("""
                SELECT COUNT(*) FROM plant_qa_history 
                WHERE question_date::date = $1
            """, today)
            
            questions_week = await conn.fetchval("""
                SELECT COUNT(*) FROM plant_qa_history 
                WHERE question_date::date >= $1
            """, week_ago)
            
            # Feedback
            feedback_today = await conn.fetchval("""
                SELECT COUNT(*) FROM feedback 
                WHERE created_at::date = $1
            """, today)
            
            feedback_week = await conn.fetchval("""
                SELECT COUNT(*) FROM feedback 
                WHERE created_at::date >= $1
            """, week_ago)
            
            # –í—ã—Ä–∞—â–∏–≤–∞–Ω–∏–µ
            growing_active = await conn.fetchval("""
                SELECT COUNT(*) FROM growing_plants 
                WHERE status = 'active'
            """)
            
            growing_completed = await conn.fetchval("""
                SELECT COUNT(*) FROM growing_plants 
                WHERE status = 'completed'
            """)
            
            # –í—Å–µ–≥–æ —Ä–∞—Å—Ç–µ–Ω–∏–π
            total_plants = await conn.fetchval("""
                SELECT COUNT(*) FROM plants
            """)
            
            total_users = await conn.fetchval("""
                SELECT COUNT(*) FROM users
            """)
            
            avg_plants_per_user = round(total_plants / total_users, 1) if total_users > 0 else 0
            
            # –¢–æ–ø-5 —Ä–∞—Å—Ç–µ–Ω–∏–π
            top_plants = await conn.fetch("""
                SELECT plant_name, COUNT(*) as count
                FROM plants
                WHERE plant_name IS NOT NULL 
                AND plant_name != ''
                AND NOT plant_name ILIKE '%–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω%'
                AND NOT plant_name ILIKE '%–Ω–µ–æ–ø–æ–∑–Ω–∞–Ω%'
                GROUP BY plant_name
                ORDER BY count DESC
                LIMIT 5
            """)
            
            return {
                "questions": {
                    "today": questions_today or 0,
                    "week": questions_week or 0
                },
                "feedback": {
                    "today": feedback_today or 0,
                    "week": feedback_week or 0
                },
                "growing": {
                    "active": growing_active or 0,
                    "completed": growing_completed or 0,
                    "total": (growing_active or 0) + (growing_completed or 0)
                },
                "plants": {
                    "total": total_plants or 0,
                    "avg_per_user": avg_plants_per_user
                },
                "top_plants": [
                    {"name": row["plant_name"], "count": row["count"]}
                    for row in top_plants
                ]
            }
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/stats/retention")
async def get_retention_stats():
    """Retention –º–µ—Ç—Ä–∏–∫–∏ - –≤–µ—Ä–Ω—É–ª–∏—Å—å —á–µ—Ä–µ–∑ 1/7/30 –¥–Ω–µ–π"""
    if not db_pool:
        raise HTTPException(status_code=500, detail="Database not connected")
    
    try:
        async with db_pool.acquire() as conn:
            retention_data = []
            
            for days in [1, 7, 30]:
                # –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (N –¥–Ω–µ–π –Ω–∞–∑–∞–¥)
                cohort_date = (datetime.now() - timedelta(days=days)).date()
                
                # –°–∫–æ–ª—å–∫–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª–æ—Å—å –≤ —Ç–æ—Ç –¥–µ–Ω—å
                cohort_users = await conn.fetchval("""
                    SELECT COUNT(*) FROM users 
                    WHERE created_at::date = $1
                """, cohort_date)
                
                if cohort_users == 0:
                    retention_data.append({
                        "days": days,
                        "cohort_date": cohort_date.isoformat(),
                        "cohort_size": 0,
                        "returned": 0,
                        "retention_percent": 0
                    })
                    continue
                
                # –°–∫–æ–ª—å–∫–æ –∏–∑ –Ω–∏—Ö –≤–µ—Ä–Ω—É–ª–∏—Å—å (–∏–º–µ—é—Ç last_activity –ø–æ—Å–ª–µ created_at)
                returned_users = await conn.fetchval("""
                    SELECT COUNT(*) FROM users 
                    WHERE created_at::date = $1
                    AND last_activity IS NOT NULL
                    AND last_activity::date > created_at::date
                """, cohort_date)
                
                retention_percent = round((returned_users / cohort_users * 100), 1) if cohort_users > 0 else 0
                
                retention_data.append({
                    "days": days,
                    "cohort_date": cohort_date.isoformat(),
                    "cohort_size": cohort_users,
                    "returned": returned_users or 0,
                    "retention_percent": retention_percent
                })
            
            return {"retention": retention_data}
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è retention –º–µ—Ç—Ä–∏–∫: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    logger.info("=" * 70)
    logger.info("üå± BLOOM AI DASHBOARD")
    logger.info("=" * 70)
    uvicorn.run(app, host="0.0.0.0", port=8080, log_level="info")
